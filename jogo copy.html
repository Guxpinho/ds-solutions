<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo 3D Redondo com Montanhas e Névoa</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Estilos básicos para o corpo e o canvas */
        body {
            margin: 0;
            overflow: hidden; /* Remove barras de rolagem */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Garante que o corpo ocupe a altura total da viewport */
            background-color: #2c3e50; /* Cor de fundo escura */
            font-family: 'Inter', sans-serif; /* Usando fonte Inter */
            color: #ecf0f1;
        }

        /* Estilo para o contêiner do jogo */
        #game-container {
            width: 90vw; /* Largura fluida */
            height: 80vh; /* Altura fluida */
            max-width: 1200px; /* Largura máxima para desktops */
            max-height: 800px; /* Altura máxima */
            position: relative;
            background-color: #34495e;
            border-radius: 15px; /* Bordas arredondadas */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5); /* Sombra para profundidade */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default; /* Cursor padrão */
        }

        canvas {
            display: block; /* Remove o espaço extra abaixo do canvas */
            width: 100% !important; /* Garante que o canvas preencha o contêiner */
            height: 100% !important; /* Garante que o canvas preencha o contêiner */
            border-radius: 15px; /* Aplica bordas arredondadas ao canvas */
        }

        /* Estilo para o painel de instruções */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            color: #ecf0f1;
            font-size: 0.9em;
            text-align: center;
            z-index: 10;
        }

        /* Estilo para o botão de pular */
        #jump-button {
            position: absolute;
            bottom: 80px; /* Posição acima das instruções */
            left: 50%;
            transform: translateX(-50%);
            background-color: #e67e22; /* Cor laranja para o botão */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        #jump-button:hover {
            background-color: #d35400; /* Laranja mais escuro ao passar o mouse */
            transform: translateX(-50%) translateY(-2px);
        }

        #jump-button:active {
            transform: translateX(-50%) translateY(0px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        /* Estilo para o botão de atirar */
        #shoot-button {
            position: absolute;
            bottom: 140px; /* Acima do botão de pular */
            left: 50%;
            transform: translateX(-50%);
            background-color: #c0392b; /* Cor vermelha para o botão de atirar */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        #shoot-button:hover {
            background-color: #a93226; /* Vermelho mais escuro ao passar o mouse */
            transform: translateX(-50%) translateY(-2px);
        }

        #shoot-button:active {
            transform: translateX(-50%) translateY(0px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }


        /* Estilos responsivos */
        @media (max-width: 768px) {
            #game-container {
                width: 95vw;
                height: 70vh;
            }
            #instructions {
                font-size: 0.8em;
                bottom: 10px;
            }
            #jump-button {
                bottom: 60px;
                padding: 10px 20px;
                font-size: 1em;
            }
            #shoot-button {
                bottom: 110px;
                padding: 10px 20px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <h1>Jogo 3D Redondo com Montanhas e Névoa</h1>
    <div id="game-container">
        <div id="instructions">
            Use **W A S D** para mover o jogador.<br>
            Use **Setas Esquerda/Direita** para girar a câmera (e o jogador).<br>
            Pressione **Espaço** ou clique em "Pular" para pular.<br>
            Pressione **F** ou clique em "Atirar" para **atirar e destruir esferas**!
        </div>
        <button id="jump-button">Pular</button>
        <button id="shoot-button">Atirar</button>
    </div>

    <script>
        let scene, camera, renderer, player, plane;
        let pickableBlocks = []; // Array para armazenar os blocos que podem ser pegos
        let activeProjectiles = []; // Novo array para armazenar projéteis ativos
        let raycaster = new THREE.Raycaster(); // Para detecção de cliques no mouse (ainda usado para coleta de esferas)
        let mouse = new THREE.Vector2(); // Armazena as coordenadas do mouse

        // Variáveis de movimento do jogador
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        
        // Variáveis de rotação do jogador (e câmera)
        let rotateLeft = false;
        let rotateRight = false;

        // Variáveis de pulo
        let isJumping = false;
        const jumpForce = 0.5; // Velocidade inicial para o pulo
        const gravity = -0.05; // Aceleração para baixo (gravidade)
        let verticalVelocity = 0; // Velocidade vertical atual

        const playerSpeed = 0.15; // Velocidade de movimento do jogador
        const playerRotationSpeed = 0.05; // Velocidade de rotação do jogador
        const projectileSpeed = 1.0; // Velocidade do projétil
        
        // Offset da câmera em relação ao jogador (x, y, z)
        // A câmera estará 3 unidades acima e 7 unidades atrás do jogador
        const cameraOffset = new THREE.Vector3(0, 3, 7); 

        const container = document.getElementById('game-container');
        const jumpButton = document.getElementById('jump-button');
        const shootButton = document.getElementById('shoot-button'); // Obtém a referência ao botão de atirar

        // Define playerRadius no escopo global para acessibilidade
        const playerRadius = 0.5;

        // Função de inicialização do ambiente 3D
        function init() {
            // 1. Cena: Onde todos os objetos, câmeras e luzes vivem.
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Céu azul claro

            // Adiciona névoa para dar um senso de profundidade
            // Cor da névoa igual à cor de fundo da cena para uma transição suave
            scene.fog = new THREE.Fog(0x87ceeb, 50, 150); // Cor, near, far

            // 2. Câmera: Define o ponto de vista do jogador (agora terceira pessoa).
            // FOV, AspectRatio, Near, Far
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            // 3. Renderizador: Responsável por renderizar a cena com a câmera.
            renderer = new THREE.WebGLRenderer({ antialias: true }); // antialiasing para bordas mais suaves
            renderer.setSize(container.clientWidth, container.clientHeight); // Define o tamanho do renderizador
            renderer.setPixelRatio(window.devicePixelRatio); // Lida com telas de alta DPI
            container.appendChild(renderer.domElement); // Adiciona o canvas ao contêiner

            // Luz ambiente para iluminar todas as partes da cena igualmente
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Cor branca, intensidade 0.7
            scene.add(ambientLight);

            // Luz direcional simulando o sol
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // Cor branca, intensidade 0.5
            directionalLight.position.set(5, 10, 7); // Posição da luz
            directionalLight.castShadow = true; // Habilita sombras para esta luz
            scene.add(directionalLight);

            // Adicionar o objeto do jogador (uma esfera azul)
            const playerGeometry = new THREE.SphereGeometry(playerRadius, 32, 32); // Geometria de uma esfera
            const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x3498db, flatShading: true }); // Material azul
            player = new THREE.Mesh(playerGeometry, playerMaterial); // Cria o objeto Mesh
            player.position.set(0, playerRadius, 0); // Posição inicial do jogador (ajustado para ficar no chão)
            player.castShadow = true; // O jogador projeta sombras
            scene.add(player);

            // Adicionar vários blocos coletáveis (agora esferas)
            const blockColors = [0xe74c3c, 0xf1c40f, 0x9b59b6, 0x1abc9c, 0x3498db, 0x95a5a6]; // Mais cores
            const blockRadius = 0.5;
            for (let i = 0; i < 15; i++) { // Mais blocos
                const blockGeometry = new THREE.SphereGeometry(blockRadius, 16, 16); // Esferas com menos segmentos
                const blockMaterial = new THREE.MeshPhongMaterial({ color: blockColors[i % blockColors.length], flatShading: true });
                const block = new THREE.Mesh(blockGeometry, blockMaterial);
                
                // Posições aleatórias para os blocos
                const x = (Math.random() - 0.5) * 50; // Área maior
                const z = (Math.random() - 0.5) * 50; // Área maior
                block.position.set(x, blockRadius, z); // Posição (ajustado para ficar no chão)
                block.castShadow = true;
                scene.add(block);
                pickableBlocks.push(block); // Adiciona o bloco ao array de blocos coletáveis
            }

            // Adicionar montanhas
            const mountainMaterial = new THREE.MeshPhongMaterial({ color: 0x7f8c8d, flatShading: true }); // Cinza para montanhas
            const peakMaterial = new THREE.MeshPhongMaterial({ color: 0xecf0f1, flatShading: true }); // Branco para picos (neve)

            function createMountain(x, z, scale, shapeType = 'cone') {
                let mountainGeometry;
                let mountainMesh;
                
                if (shapeType === 'cone') {
                    // Montanhas mais pontudas (cones)
                    mountainGeometry = new THREE.ConeGeometry(scale * 3, scale * 6, 16); // Mais altas, menos segmentos para look "low poly"
                } else if (shapeType === 'icosahedron') {
                    // Montanhas mais arredondadas/orgânicas (icosaedros)
                    mountainGeometry = new THREE.IcosahedronGeometry(scale * 3.5, 0); // Ligeiramente maiores
                } else { // 'multi-peak' - Tentativa de algo mais complexo
                    // Combinação de várias formas para uma montanha mais complexa
                    const group = new THREE.Group();
                    const baseRadius = scale * 4;
                    const baseHeight = scale * 3;
                    const baseGeometry = new THREE.CylinderGeometry(baseRadius, baseRadius * 0.8, baseHeight, 16);
                    const baseMesh = new THREE.Mesh(baseGeometry, mountainMaterial);
                    baseMesh.position.y = baseHeight / 2;
                    group.add(baseMesh);

                    for (let i = 0; i < 3; i++) {
                        const peakScale = scale * (0.5 + Math.random() * 0.5);
                        const peakGeometry = new THREE.ConeGeometry(peakScale * 2, peakScale * 4, 12);
                        const peakMesh = new THREE.Mesh(peakGeometry, mountainMaterial);
                        peakMesh.position.x = (Math.random() - 0.5) * baseRadius * 0.8;
                        peakMesh.position.z = (Math.random() - 0.5) * baseRadius * 0.8;
                        peakMesh.position.y = baseHeight + (peakScale * 4) / 2 - 0.5;
                        group.add(peakMesh);
                    }
                    mountainMesh = group; // O mesh é o grupo em si
                }

                if (mountainMesh === undefined) { // Se não for 'multi-peak', cria o Mesh aqui
                    mountainMesh = new THREE.Mesh(mountainGeometry, mountainMaterial);
                    mountainMesh.position.y = mountainGeometry.parameters.height / 2 || mountainGeometry.parameters.radius; // Ajusta a posição Y
                }
                
                mountainMesh.position.x = x;
                mountainMesh.position.z = z;
                mountainMesh.castShadow = true;
                mountainMesh.receiveShadow = true;
                scene.add(mountainMesh);

                // Adicionar um pico de neve para cones
                if (shapeType === 'cone') {
                    const peakGeometry = new THREE.SphereGeometry(scale * 1.5, 16, 16);
                    const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                    peak.position.set(x, (scale * 6), z); // Ajustado para a nova altura do cone
                    peak.castShadow = true;
                    scene.add(peak);
                }
            }

            // Criar várias montanhas em posições aleatórias na borda da cena
            const numberOfMountains = 15; // Mais montanhas
            const minRadius = 60; // Começa mais longe para um senso de ambiente maior
            const maxRadius = 150; // Vai mais longe
            for (let i = 0; i < numberOfMountains; i++) {
                const scale = 3 + Math.random() * 7; // Tamanho maior e mais variado
                const angle = Math.random() * Math.PI * 2;
                const radius = minRadius + Math.random() * (maxRadius - minRadius); // Distância do centro
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Variar os tipos de montanha
                const typePicker = Math.random();
                let mountainType = 'cone';
                if (typePicker < 0.4) { // 40% cones
                    mountainType = 'cone';
                } else if (typePicker < 0.8) { // 40% icosaedros
                    mountainType = 'icosahedron';
                } else { // 20% multi-pico (mais complexo)
                    mountainType = 'multi-peak';
                }
                createMountain(x, z, scale, mountainType);
            }

            // Adicionar um plano para o chão
            const planeGeometry = new THREE.PlaneGeometry(300, 300); // Plano muito maior para caber as montanhas e a névoa
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x2ecc71, side: THREE.DoubleSide }); // Material verde
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2; // Gira o plano para que fique horizontal
            plane.position.y = 0; // Coloca o plano no chão
            plane.receiveShadow = true; // O plano recebe sombras
            scene.add(plane);

            // Configurar o renderizador para sombras
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Tipo de mapa de sombra para sombras mais suaves

            // Event Listeners para interação
            addEventListeners();

            // Iniciar o loop de animação
            animate();
        }

        // Função para adicionar listeners de eventos
        function addEventListeners() {
            // Eventos do teclado para movimento e rotação
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Evento do mouse para coleta de blocos (agora só coleta com clique)
            container.addEventListener('click', onMouseClick);

            // Evento de clique do botão de pular
            jumpButton.addEventListener('click', onJumpButtonClick);

            // Evento de clique do botão de atirar
            shootButton.addEventListener('click', onShootButtonClick);

            // Evento para redimensionamento da janela
            window.addEventListener('resize', onWindowResize);
        }

        // --- Funções de Eventos do Teclado ---

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'ArrowLeft': // Seta esquerda para girar o jogador para a esquerda
                    rotateLeft = true;
                    break;
                case 'ArrowRight': // Seta direita para girar o jogador para a direita
                    rotateRight = true;
                    break;
                case 'Space': // Barra de espaço para pular
                    onJumpButtonClick();
                    break;
                case 'KeyF': // Tecla F para atirar
                    onShootButtonClick();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ArrowLeft':
                    rotateLeft = false;
                    break;
                case 'ArrowRight':
                    rotateRight = false;
                    break;
            }
        }

        // --- Função de Evento do Mouse para Coletar Blocos (agora só coleta com clique) ---
        function onMouseClick(event) {
            // Calcula as coordenadas do mouse normalizadas (-1 a +1)
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Atualiza o raio com a câmera e as coordenadas do mouse
            raycaster.setFromCamera(mouse, camera);

            // Encontra todos os objetos que o raio intersecta
            const intersects = raycaster.intersectObjects(pickableBlocks);

            // Se houver objetos intersectados, pegue o primeiro (o mais próximo)
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                
                // Remove o objeto da cena
                scene.remove(intersectedObject);
                
                // Remove o objeto do array de blocos coletáveis para que não seja mais detectado
                pickableBlocks.splice(pickableBlocks.indexOf(intersectedObject), 1);
                console.log("Esfera coletada!");
            }
        }

        // --- Função de Clique do Botão de Pular ---
        function onJumpButtonClick() {
            // Permite pular apenas se não estiver pulando (no chão)
            if (!isJumping) {
                isJumping = true;
                verticalVelocity = jumpForce; // Aplica a força inicial de pulo
            }
        }

        // --- Função de Clique do Botão de Atirar e Tecla F ---
        function onShootButtonClick() {
            // Cria a geometria e o material para o projétil (uma pequena esfera vermelha)
            const projectileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xff4500 }); // Laranja avermelhado

            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            // Define a posição inicial do projétil ligeiramente à frente do jogador
            const playerForward = new THREE.Vector3();
            player.getWorldDirection(playerForward); // Obtém a direção para onde o jogador está olhando

            projectile.position.copy(player.position);
            projectile.position.y += playerRadius / 2; // Posiciona um pouco acima do centro do jogador
            projectile.position.add(playerForward.multiplyScalar(playerRadius + 0.1)); // Um pouco à frente do jogador

            // Define a velocidade e a direção do projétil
            projectile.velocity = playerForward.normalize().multiplyScalar(projectileSpeed);
            
            scene.add(projectile);
            activeProjectiles.push(projectile); // Adiciona o projétil ao array de projéteis ativos
            console.log("Atirou um projétil!");
        }

        function onWindowResize() {
            // Atualiza o aspect ratio da câmera
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix(); // Atualiza a matriz de projeção da câmera

            // Atualiza o tamanho do renderizador
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Loop de animação
        function animate() {
            requestAnimationFrame(animate); // Solicita o próximo frame de animação

            // --- Movimento do jogador ---
            const moveDirection = new THREE.Vector3(0, 0, 0);

            if (moveForward) {
                moveDirection.z -= 1; // Movimento para frente no eixo Z local
            }
            if (moveBackward) {
                moveDirection.z += 1; // Movimento para trás no eixo Z local
            }
            if (moveLeft) {
                moveDirection.x -= 1; // Movimento para esquerda no eixo X local
            }
            if (moveRight) {
                moveDirection.x += 1; // Movimento para direita no eixo X local
            }

            // Normaliza a direção para que o movimento diagonal não seja mais rápido
            if (moveDirection.lengthSq() > 0) { // Verifica se há movimento antes de normalizar
                moveDirection.normalize();
                // Aplica o movimento na direção local do jogador
                player.translateX(moveDirection.x * playerSpeed);
                player.translateZ(moveDirection.z * playerSpeed);
            }

            // --- Rotação do jogador ---
            if (rotateLeft) {
                player.rotation.y += playerRotationSpeed;
            }
            if (rotateRight) {
                player.rotation.y -= playerRotationSpeed;
            }

            // --- Lógica de Pulo / Gravidade ---
            if (isJumping) {
                player.position.y += verticalVelocity; // Aplica a velocidade vertical
                verticalVelocity += gravity; // Aplica a gravidade (diminui a velocidade)

                // Se o jogador atingir o chão (ou for abaixo dele)
                if (player.position.y <= playerRadius) { // Usando playerRadius, que agora está no escopo global
                    player.position.y = playerRadius; // Volta para o chão
                    isJumping = false; // Para de pular
                    verticalVelocity = 0; // Reseta a velocidade vertical
                }
            }

            // --- Atualização e Colisão de Projéteis ---
            for (let i = activeProjectiles.length - 1; i >= 0; i--) {
                const projectile = activeProjectiles[i];
                projectile.position.add(projectile.velocity); // Move o projétil

                // Cria um Raycaster para detecção de colisão do projétil
                // A origem é a posição atual do projétil e a direção é a sua velocidade normalizada
                const projectileRaycaster = new THREE.Raycaster(
                    projectile.position,
                    projectile.velocity.clone().normalize()
                );
                
                // Verifica interseções com os blocos coletáveis
                const intersects = projectileRaycaster.intersectObjects(pickableBlocks);

                if (intersects.length > 0) {
                    const hitBlock = intersects[0].object;
                    
                    // Remove o bloco atingido da cena e do array
                    scene.remove(hitBlock);
                    pickableBlocks.splice(pickableBlocks.indexOf(hitBlock), 1);
                    console.log("Esfera destruída por projétil!");

                    // Remove o projétil da cena e do array
                    scene.remove(projectile);
                    activeProjectiles.splice(i, 1);
                } else if (projectile.position.distanceTo(player.position) > 100) { // Remove projétil se for muito longe
                    scene.remove(projectile);
                    activeProjectiles.splice(i, 1);
                }
            }

            // --- Atualização da câmera (seguindo o jogador) ---
            const tempCameraPosition = new THREE.Vector3();
            // Aplica o offset da câmera em relação à rotação atual do jogador
            tempCameraPosition.copy(cameraOffset).applyQuaternion(player.quaternion);
            // Define a posição final da câmera adicionando à posição do jogador
            camera.position.copy(player.position).add(tempCameraPosition);
            
            // Faz a câmera olhar para o jogador
            camera.lookAt(player.position);

            renderer.render(scene, camera); // Renderiza a cena com a câmera
        }

        // Iniciar a aplicação 3D quando a janela estiver totalmente carregada
        window.onload = init;
    </script>
</body>
</html>